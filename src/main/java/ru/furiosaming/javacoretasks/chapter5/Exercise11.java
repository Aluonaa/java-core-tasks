package main.java.ru.furiosaming.javacoretasks.chapter5;


public class Exercise11 {
    /** Сравните вызов Objects.requireNonNull(obj) с утверждением assert obj !=
    null.

    Решение: плюсы использования Objects.requireNonNull(obj):

    Если он потерпит неудачу, лучше потерпеть неудачу раньше,
    чем позже. Это позволяет выявлять проблемы ближе к их источнику, что
    облегчает их выявление и восстановление. Это также позволяет избежать
    траты циклов ЦП на код, который обречен на сбой.

    Отбрасывание исключения явно дает понять другим разработчикам,
    что ошибка существует намеренно и автор знал о последствиях.

    Если бы ошибка произошла естественным образом, она могла бы произойти
    не в каждом сценарии. Например, если сопоставление не найдено, оно никогда
    не будет использоваться, и исключение не будет создано. Предварительная
    проверка входных данных позволяет получить более детерминированное поведение.

    Код развивается с течением времени. Код, который сталкивается с исключением,
    естественно, может после небольшого рефакторинга перестать это делать или
    сделать это при других обстоятельствах. Бросание его явно снижает вероятность
    изменения поведения.

    Кроме того: местоположение, из которого генерируется исключение,
    привязано ровно к одной проверяемой переменной. Без него исключение может быть связано
    с тем, что одна из нескольких переменных имеет значение null

    Но это решение более удобно для использования с лямбда-выражениями. Когда мы используем
    функциональные операции, подобные приведенному ниже примеру, мы можем более удобно
    применять проверки null, и, в частности, используя метод requireNonNull, мы можем
    легко исключить значения null.

    Допустим, у нас есть 100 элементов в этом ArrayList, а некоторые случайные значения
    равны нулю, и в то же время нам нужно обработать эти ненулевые значения. Затем
    мы можем реализовать следующее:

     list.stream().map(Objects::requireNonNull).forEach(obj -> {
     // действия
     });

     Утверждения используются в основном в JUnit или других инструментах тестирования для
     проверки/утверждения результатов теста. Таким образом, это может создать ложное
     впечатление у других разработчиков, что метод является тестовым методом.

     Утверждения удаляются во время выполнения, если при компиляции кода явно не указано
     «включение утверждений». Утверждения Java не должны использоваться в рабочем коде
     и должны быть ограничены закрытыми методами
     **/

}
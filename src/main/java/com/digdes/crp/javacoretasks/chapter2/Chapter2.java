package com.digdes.crp.javacoretasks.chapter2;

import java.util.*;

public class Chapter2 {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        //Выбор задания главы 2
        System.out.println("Введите номер задания (в данный момент выполнены: 2-7, 9-11 и 15):");
        int numberOfExercise = scanner.nextInt();

        /** ТЕКСТ ЗАДАНИЙ **/
//            1. Измените представленную в этой главе программу вывода календаря таким образом,
//             чтобы неделя начиналась с воскресенья. Кроме того, организуйте перевод на новую
//             строку в конце предыдущей, но только один раз.
//
//            2. Проанализируйте метод nextInt() из класса Scanner. Является ли он методом
//            доступа или модифицирующим методом и почему? А что можно сказать о
//            методе nextInt() из класса Random ?
//
//            3. Может ли модифицирующий метод вообще возвращать что-нибудь, кроме
//            типа void ? Можно ли создать метод доступа с возвращаемым типом void , т.е.
//            ничего фактически не возвращающий? Приведите по возможности примеры
//            таких методов.
//
//            4. Почему в Java нельзя реализовать метод, меняющий местами содержимое двух
//            переменных типа int? Вместо этого напишите метод, меняющий местами
//            содержимое двух объектов типа IntHolder. (Описание этого малоизвестного
//            класса можно найти в документации на прикладной программный интерфейс Java API.)
//             Можно ли поменять местами содержимое двух объектов типа Integer?
//
//            5. Реализуйте неизменяемый класс Point , описывающий точку на плоскости.
//            Предоставьте его конструктор, чтобы задать конкретную точку; конструктор
//            без аргументов, чтобы задать точку в начале координат; а также методы getX(),
//            getY(), translate() и scale(). В частности, метод translate()
//             должен перемещать точку на определенное расстояние в направлении координат х и у, а
//            метод scale() — изменять масштаб по обеим координатам на заданный коэффициент.
//             Реализуйте эти методы таким образом, чтобы они возвращали новые
//            точки в качестве результата. Например, в следующей строке кода:
//            Point р = new Point(3, 4).translate(1, 3).scale(0.5);
//            в переменной р должна быть установлена точка с координатами (2, 3,5).
//
//            6. Повторите предыдущее упражнение, но на этот раз сделайте методы
//             translate() и scale() модифицирующими.
//
//            7. Введите документирующие комментарии в обе версии класса Point из предыдущих упражнений.
//
//            8. В предыдущих упражнениях для предоставления конструкторов и методов получения из класса
//             Point пришлось писать часто повторяющийся код. В большинстве ИСР имеются средства,
//             упрощающие написание повторяющегося шаблонного кода. Имеются ли такие средства в применяемой вами ИСР?
//
//            9. Реализуйте класс Саr, моделирующий передвижение автомобиля на бензиновом
//             топливе по оси х. Предоставьте методы для передвижения автомобиля на
//            заданное количество километров, заполнения топливного бака заданным количеством
//             литров бензина, вычисления расстояния, пройденного от начала
//            координат, а также уровня топлива в баке. Укажите расход топлива (в км/л)
//            в качестве параметра конструктора данного класса. Должен ли этот класс быть
//            неизменяемым и почему?
//
//            10. Предоставьте в классе RandomNumbers два статических метода типа random
//            Element, получающих произвольный элемент из обычного или списочного
//            массива целочисленных значений. (Если обычный или списочный массив пуст,
//            должен быть возвращен нуль.) Почему эти методы нельзя сделать методами
//            экземпляра типа t [ ] или ArrayList <Integer> ?
//
//            11. Перепишите класс Са1, чтобы использовать в нем статический импорт классов
//            S y s t e m и L o c a lD a t e .
//
//            12. Создайте исходный файл H e ll o W o r l d . ja v a , где класс
//             H e ll o W o r l d объявляется в пакете c h O l. s e c O l.
//             Разметите его в каком-нибудь каталоге, но только не в подкаталоге
//             c h O l/ s e c O l. Выполните из этого каталога команду j a v a c
//            H e llo W o r ld . j a v a . Получите ли вы в итоге файл класса и где именно? Затем
//            выполните команду j a v a H e llo W o rld . Что при этом произойдет и почему?
//            (Подсказка: выполните команду j a v a p H e llo W o rld и проанализируйте
//             полученное предупреждающее сообщение.) И наконец, попробуйте выполнить команду
//             j a v a c - d . H e llo W o rld . j a v a . Почему такой способ лучше?
//
//            13. Загрузите архивный ]AR-файл с библиотекой OpenCSV по адресу h t t p : / /
//            o p e n c s v . s o u r c e f o r g e . n e t .
//             Напишите класс с методом m a in ( ) для чтения избранных файлов формата
//             CSV и вывода некоторого их содержимого. Соответствующий образец кода
//             можно найти на веб-сайте библиотеки OpenCSV по
//            указанному выше адресу. А поскольку вы еще не научились обрабатывать
//             исключения, го воспользуйтесь следующим заголовком для метода m a in ():
//            public static void main(String[] args) throws Exception
//            Назначение данного упражнения — не сделать что-нибудь полезное с файлами
//            формата CSV, но поупражняться в применении библиотеки, предоставляемой
//            в упомянутом выше архивном JAR-файле.
//
//            14. Скомпилируйте класс N e tw o rk , представленный в этой главе.
//             Обратите внимание на то, что файл внутреннего класса называется
//             N e tw o rk $ M e m b e r.c la s s . Воспользуйтесь утилитой ja v a p ,
//             чтобы исследовать сгенерированный код. Так, по следующей команде:
//            javap - p r i v a t e имяКласса
//            выводятся методы и переменные экземпляра. Выявите среди выводимых
//             результатов ссылку на объемлющий класс. (В Linux и Mac OS X перед знаком $
//            в имени класса следует указать знак \ при выполнении утилиты ja v a p .)
//
//            15. Реализуйте полностью класс Invoice, представленный в разделе 2.6.1.
//             Предоставьте метод, выводящий счет-фактуру, и демонстрационную версию программы,
//             составляющей и выводящей образец счета-фактуры.
//
//            16. Реализуйте в классе Queue неограниченную очередь символьных строк.
//             Предоставьте метод add () для ввода элемента в хвост очереди и метод remove ()
//            для удаления элемента из головы очереди. Организуйте хранение элементов
//            в виде связного списка узлов, создав вложенный класс Node. Должен ли этот
//            класс быть статическим?
//
//            17. Предоставьте итератор — объект, извлекающий по порядку элементы очереди из
//             предыдущего упражнения. Сделайте класс Iterator вложенным и определите в нем методы
//             next() и hasNext(). Определите в классе Queue метод
//            iterator (), возвращающий ссылку на объект Queue .Iterator.
//             Должен ли внутренний класс Iterator быть статическим?

        switch (numberOfExercise) {
            case (2):

                System.out.println("Проанализируйте метод nextlnt() из класса Scanner. Является ли он методом\n" +
                        "//        доступа или модифицирующим методом и почему? А что можно сказать о методе nextlnt() из класса Random\n" +
                        "//\n" +
                        "//        Решение: метод класса Scanner является модифицирующим, так как при исключении\n" +
                        "//        NumberFormatException меняется поле position. Также он считывает информацию,\n" +
                        "//        вводимую пользователем, поэтому является методом доступа.\n" +
                        "//        Метод класса Random является модифицирующим, так как в процессе генерирования\n" +
                        "//        псевдорандома меняется поле seed.");

                break;

            case (3):

                System.out.println("Может ли модифицирующий метод вообще возвращать что-нибудь, кроме\n" +
                        "//        типа void ? Можно ли создать метод доступа с возвращаемым типом void , т.е.\n" +
                        "//        ничего фактически не возвращающий? Приведите по возможности примеры\n" +
                        "//        таких методов\n" +
                        "//\n" +
                        "//        Решение: ответ на оба вопроса - да, может. В первом случае тип возвращаемого значения\n" +
                        "//        вообще никак не характеризует метод как модифицирующий или не модифицирующий.\n" +
                        "//        Для него оценивается сам факт модификации объекта, для которого был вызван метод.\n" +
                        "//        Во втором вопросе да, потому что доступ к полю, например, может быть получен путем\n" +
                        "//        присваивания ссылки на это поле другому полю. Внешнему. То есть в метод должно\n" +
                        "//        передаваться поле с изменяемым типом, которое  при присваивании скопирует ссылку первого поля.\n" +
                        "//        Тогда ничего возвращать не нужно.");
                break;

            case (4):

                System.out.println("Почему в Java нельзя реализовать метод, меняющий местами содержимое двух\n" +
                        "//        переменных типа int ? Можно ли поменять местами содержимое двух объектов типа Integer?\n" +
                        "\n" +
                        "//        Решение: потому что переменные в метод будут передаваться по значению." +
                        "          То есть значение просто будет\n" +
                        "//        скопировано. А старое переданное значение не изменится.  поменять местами" +
                        "          содержимое двух объектов типа Integer\n" +
                        "//        нельзя, так как оболочки всех типов являются неизменяемыми." +
                        "          Это из-за отсутствия эквивалента setValue. Данное устройство\n" +
                        "//        позволяет повысить безопасность и избежать постоянного контроля за методами," +
                        "          в случае, если они вдруг изменят данные оболочки");
                break;

            case (5):

                Plane.Point point = new Plane.Point();
                point.translate(1, 3);
                point.scale(5);
                point.getX();
                point.getY();
                System.out.println(point);
                break;

            case (9):

                Car car = new Car(20);
                car.refueling(100);
                car.getFuelTank();
                car.ride(600);
                System.out.println(car.getDistance());
                break;

            case (10):

//                List<String> listForRandom = new ArrayList<>();
//                listForRandom.add("1");
//                listForRandom.add("2");
//                listForRandom.add("3");
//                listForRandom.add("4");
//                listForRandom.add("5");
//                listForRandom.add("6");
//                listForRandom.add("7");
//                String resultRandomFromList = RandomNumbers.randomNumberFromList(listForRandom);
//                System.out.println(resultRandomFromList);
//
//                Integer[] arrayForRandom = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
//                int resultRandomFromArray = Math.random(arrayForRandom);
//                        //RandomNumbers.randomNumberFromArray(arrayForRandom);
//                System.out.println(resultRandomFromArray);
//                break;


            case (15):
                Invoice invoice = new Invoice();
                Invoice.Item newltem1 = new Invoice. Item ("Тостер", 2, 1900);
                Invoice.Item newltem2 = new Invoice. Item ("Микроволновка", 2, 2300);
                Invoice.Item newltem3 = new Invoice. Item ("Холодильник", 2, 3300);
                invoice.add(newltem1);
                invoice.add(newltem2);
                invoice.add(newltem3);
                invoice.showInvoice();
                break;
        }
    }
}

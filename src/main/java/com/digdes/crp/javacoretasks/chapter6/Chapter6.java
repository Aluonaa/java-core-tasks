package com.digdes.crp.javacoretasks.chapter6;

import java.util.ArrayList;
import java.util.Scanner;

public class Chapter6<T> {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        //Выбор задания главы 6
        System.out.println("Введите номер задания (в данный момент выполнены: 1, 24):");
        int numberOfExercise = scanner.nextInt();

        /** ТЕКСТ ЗАДАНИЙ **/
//        1. Реализуйте обобщенный класс Stack<E>, управляющий списочным массивом,
//        состоящим из элементов типа Е. Предоставьте методы push(), рор() и isEmpty().

//        2. Еще раз реализуйте обобщенный класс Stack<E>, используя массив для хранения элементов.
//        Если требуется, нарастите массив в методе push(). Предоставьте два решения этой задачи:
//        одно — с массивом типа Е [], другое — с массивом типа Object [].
//        Оба решения должны компилироваться без всяких предупреждений.
//        Какое из них вы предпочтете сами и почему?

//        3. Реализуйте обобщенный класс Table<K, V>, управляющий списочным массивом,
//        состоящим из элементов типа Entry<K, V>. Предоставьте методы для
//        получения значения, связанного с ключом, установки значения по заданному ключу и удаления ключа.

//        4. Сделайте вложенным класс Entry из предыдущего упражнения. Должен ли этот класс быть обобщенным?
//        5. Рассмотрите следующий вариант метода swap (), где массив может быть предоставлен с
//        помощью аргументов переменной длины:
//        public static <Т> Т[] swap(int i, int j, T... values) {
//            T temp = values[i];
//            values[i] = values [j];
//            values[j] = temp;
//            return values;
//            А теперь рассмотрите следующий вызов:
//            Doublet] result = Arrays.swap(0, 1, 1.5, 2, 3);
//            Какое сообщение об ошибке вы получите? Далее сделайте такой вызов:
//            Doublet] result = Arrays.<Double>swap(0, 1, 1.5, 2, 3);
//            Изменилось ли к лучшему сообщение об ошибке? Что нужно сделать для
//            устранения ошибки?

//            6. Реализуйте обобщенный метод, присоединяющий все элементы из одного
//            списочного массива к другому. Воспользуйтесь метасимволом подстановки для
//            обозначения одного из аргументов типа. Предоставьте два равнозначных решения:
//            одно с подстановочным типом ? e x t e n d s Е, другое — с подстановочным
//            типом ? s u p e r Е.

//            7. Реализуйте обобщенный класс Pair<E>, позволяющий сохранять пару элементов типа Е.
//            Предоставьте методы доступа для получения первого и второго элементов.

//            8. Видоизмените класс из предыдущего упражнения, введя методы mах() и min()
//            для получения наибольшего и наименьшего из двух элементов. Наложите
//            соответствующее ограничение на обобщенный тип Е.

//            9. Предоставьте в служебном классе Arrays следующий метод, возвращающий
//            пару, состоящую из первого и последнего элементов массива а, указав
//            подходящий аргумент типа: public static <Е> Pair<E> firstLast(ArrayList<__ > a)

//            10. Предоставьте в служебном классе A r r a y s обобщенные методы min( ) и mах(),
//            возвращающие наименьший и наибольший элементы массива соответственно.

//            11. Продолжая предыдущее упражнение, предоставьте метод minMax(),
//            возвращающий объект типа P a i r с наименьшим и наибольшим элементами массива.
//            12. Реализуйте следующий метод, сохраняющий наименьший и наибольший элементы
//            из массива e le m e n t s в списке r e s u l t :
//            public static <Т> void minmax(List<T> elements, Comparator<? super T> comp,
//            List<? super T> result) Обратите внимание на подстановочный тип в последнем
//            параметре. Для хранения полученного результата подойдет любой супертип обобщенного типа Т.

//            13. С учетом метода из предыдущего упражнения рассмотрите следующий метод:
//            public static <Т> void maxmin(List<T> elements,
//                    Comparator<? super T> comp, List<? super T> result) {
//                minmax(elements, comp, result);
//            }
//            Почему этот метод нельзя скомпилировать без захвата подстановки? Подсказка:
//            попробуйте предоставить явный тип L i s t s . <____> s w a p H e lp e r ( r e s u l t , 0, 1).

//            14. Реализуйте усовершенствованный вариант метода c l o s e A l l (),
//            представленного в разделе 6.3. Закройте все элементы даже в том случае, если некоторые из
//            них генерируют исключение. В таком случае сгенерируйте исключение впоследствии.
//            Если исключение генерируется в результате двух или больше вызовов данного метода,
//            свяжите их в цепочку.

//            15. Реализуйте метод mар() , получающий списочный массив и объект типа
//            F u n c t io r K T , R> (см. главу 3) и возвращающий списочный массив, состоящий
//            из результатов применения функции к заданным элементам этого массива.

//            16. К чему приведет стирание типов в приведенных ниже методах из класса C o l l e c t i o n ?

//            public static <Т extends Comparable<? super Т »
//            void sort(List<T> list)
//            public static <T extends Object & Comparable<? super Т »
//            T max (Collections extends T> coll)

//            17. Определите класс Em p lo ye e , реализующий интерфейс C o m p a ra b le < E m p lo y e e > .
//            Используя утилиту javap, продемонстрируйте, что мостовой метод был синтезирован. Каково его назначение?

//            18. Рассмотрите следующий метод, представленный в разделе 6.6.3:
//            public static <Т> Т[] repeat(int n, Т obj, IntFunction<T[]> constr)
//            Почему исход вызова A r r a y s . r e p e a t ( 10, 42, i n t [ ] : :new )
//            окажется неудачным? Как устранить этот недостаток? Что нужно сделать для применения других примитивных типов?

//            19. Рассмотрите следующий метод, представленный в разделе 6.6.3:
//            public static <Т> ArrayList<T> repeat(int n, T obj)
//            Этот метод без особых хлопот составляет списочный массив типа A r r a y L is t < T >
//            из элементов обобщенного типа Т. Можно ли получить массив типа Т [ ] из
//            этого списочного массива, не пользуясь объектом типа C l a s s или ссылкой на
//            конструктор? Если нельзя, то почему?

//            20. Реализуйте следующий метод:
//            @SafeVarargs public static final <T> T[] repeat(int n, T... objs)
//            Он должен возвращать массив n копий заданных объектов. Имейте в виду, что
//            для этого не потребуется объект типа C l a s s или ссылка на конструктор,
//            поскольку наращивать количество объектов o b j s можно рефлексивно.

//            21. Используя аннотацию @SafeVarargs, напишите метод, позволяющий строить
//            массивы обобщенных типов, как в следующем примере:
//            Lists.swapHelper(result, 0, 1);
//              }
//              List<String>[ ] result = Arrays.<List<String»construct (10) ;
//           Устанавливает результат в списке типа List<String>[] длиной 10

//           22. Усовершенствуйте метод p u b l i c s t a t i c <V, Т> V d o W o r k ( C a lla b le < V > с, T ex)
//           t h ro w s T, представленный в разделе 6.6.7, таким образом, чтобы передавать ему
//           объект исключения, который вряд ли будет вообще использован. Вместо этого
//           данный метод должен принимать ссылку на класс исключения.

//           23. Во врезке "Внимание!" из раздела 6.6.7 упоминается вспомогательный метод t h ro w A s (),
//           применяемый для "приведения" типа исключения ех к типу
//           R u n t im e E x c e p t io n и его генерирования. Почему для этой цели нельзя воспользоваться
//           обычным приведением типов, т.е. th ro w ( R u n t im e E x c e p t io n ) e x ?

//           24. Какие методы можно вызвать для переменной типа Class<?> , не прибегая к
//           приведению типов?

//           25. Напишите метод p u b lic s t a t ic S t r in g g e n e ric D e c la ra tio n (Method m),
//           возвращающий объявление метода m(), перечисляющего параметры типа с их ограничениями и типами
//           параметров метода, включая их аргументы типа, если это обобщенные типы

        switch (numberOfExercise) {
            case (1):
                ArrayList<String> arrayList = new ArrayList<>();
                arrayList.add("Hello1");
                arrayList.add("Hello2");
                arrayList.add("Hello3");
                arrayList.add("Hello4");
                arrayList.add("Hello5");
                Stack<String> stringStack = new Stack<String>(arrayList);
                System.out.println(stringStack.isEmpty());
                System.out.println(stringStack.pop());
                stringStack.push("Hello0");

                System.out.println(stringStack);
                break;



            case (5):

//                Double[] result = Arrays.swap(0, 1, 1.5, 2, 3);
//
//                Double[] result1 = Arrays.<Double>swap(0, 1, 1.5, 2, 3);
//                Рассмотрите следующий вариант метода swap (), где массив может быть предоставлен с помощью ар1ументов переменной длины:
//            public static <Т> Т[] swap(int i, int j, T... values) {
//                T temp = values[i];
//                values[i] = values [j];
//                values[j] = temp;
//                return values;
//                А теперь рассмотрите следующий вызов:
//                Doublet] result = Arrays.swap(0, 1, 1.5, 2, 3);
//                Какое сообщение об ошибке вы получите? Далее сделайте такой вызов:
//                Doublet] result = Arrays.<Double>swap(0, 1, 1.5, 2, 3);
//                Изменилось ли к лучшему сообщение об ошибке? Что нужно сделать для
//                устранения ошибки?
//                public static <Т > Т[]swap( int i, int j, T...values){
//                T temp = values[i];
//                values[i] = values [j];
//                values[j] = temp;
//                return values;

            case (24):
                System.out.println("aClass.toString();\n" +
                        "                aClass.desiredAssertionStatus();\n" +
                        "                aClass.getAnnotatedInterfaces();\n" +
                        "                aClass.getAnnotations();\n" +
                        "                aClass.getCanonicalName();\n" +
                        "                aClass.getClasses();\n" +
                        "                aClass.getClassLoader();\n" +
                        "                aClass.getComponentType();\n" +
                        "                aClass.getConstructors();\n" +
                        "                aClass.getDeclaredAnnotations();\n" +
                        "                aClass.getDeclaredClasses();\n" +
                        "                aClass.getDeclaredFields();\n" +
                        "                aClass.getDeclaredConstructors();\n" +
                        "                aClass.getFields();\n" +
                        "                aClass.getMethods();\n" +
                        "                aClass.getModifiers();");
            break;
        }
    }


    public <Т> T[] swap(int i, int j, T... values) {
        T temp = values[i];
        values[i] = values[j];
        values[j] = temp;
        return values;
    }
}
